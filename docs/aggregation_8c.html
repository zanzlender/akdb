<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kalashnikov DB: rel/aggregation.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalashnikov DB
   &#160;<span id="projectnumber">0.9.3</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('aggregation_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">aggregation.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="aggregation_8h_source.html">aggregation.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for aggregation.c:</div>
<div class="dyncontent">
<div class="center"><img src="aggregation_8c__incl.png" border="0" usemap="#rel_2aggregation_8c" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91490139be5ae263a0f79085353929d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsearch__result.html">search_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aggregation_8c.html#a91490139be5ae263a0f79085353929d8">AK_search_unsorted</a> (char *szRelation, <a class="el" href="structsearch__params.html">search_params</a> *aspParams, int iNum_search_params)</td></tr>
<tr class="memdesc:a91490139be5ae263a0f79085353929d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that searches through unsorted values of multiple attributes in a segment. Only tuples that are equal on all given attribute values are returned (A == 1 AND B == 7 AND ...). SEARCH_RANGE is inclusive. Only one value (or range) per attribute allowed - use <a class="el" href="structsearch__params.html#a061c7b5e9a3163f19dac0d3a681d63d0" title="pointer to lower value of search range">search_params.pData_lower</a> for SEARCH_PARTICULAR. Supported types for SEARCH_RANGE: TYPE_INT, TYPE_FLOAT, TYPE_NUMBER, TYPE_DATE, TYPE_DATETIME, TYPE_TIME. Do not provide the wrong data types in the array of search parameters. There is no way to test for that and it could cause a memory access violation.  <a href="aggregation_8c.html#a91490139be5ae263a0f79085353929d8">More...</a><br /></td></tr>
<tr class="separator:a91490139be5ae263a0f79085353929d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abace9faf5a77b69ad08b10086556b47b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aggregation_8c.html#abace9faf5a77b69ad08b10086556b47b">AK_header_size</a> (<a class="el" href="structAK__header.html">AK_header</a> *header)</td></tr>
<tr class="memdesc:abace9faf5a77b69ad08b10086556b47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calculates how many attributes there are in the header with a while loop.  <a href="aggregation_8c.html#abace9faf5a77b69ad08b10086556b47b">More...</a><br /></td></tr>
<tr class="separator:abace9faf5a77b69ad08b10086556b47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8db5150c0790b36ae56526280e47599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aggregation_8c.html#af8db5150c0790b36ae56526280e47599">AK_agg_input_init</a> (<a class="el" href="structAK__agg__input.html">AK_agg_input</a> *input)</td></tr>
<tr class="memdesc:af8db5150c0790b36ae56526280e47599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes the input object for aggregation with init values.  <a href="aggregation_8c.html#af8db5150c0790b36ae56526280e47599">More...</a><br /></td></tr>
<tr class="separator:af8db5150c0790b36ae56526280e47599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98d6f8022efcff9d02f0b8b6f62b646"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aggregation_8c.html#af98d6f8022efcff9d02f0b8b6f62b646">AK_agg_input_add</a> (<a class="el" href="structAK__header.html">AK_header</a> header, int agg_task, <a class="el" href="structAK__agg__input.html">AK_agg_input</a> *input)</td></tr>
<tr class="memdesc:af98d6f8022efcff9d02f0b8b6f62b646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that adds a header with a task in input object for aggregation.  <a href="aggregation_8c.html#af98d6f8022efcff9d02f0b8b6f62b646">More...</a><br /></td></tr>
<tr class="separator:af98d6f8022efcff9d02f0b8b6f62b646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c630754ec1a2714e3b04b5753b2d0f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aggregation_8c.html#a3c630754ec1a2714e3b04b5753b2d0f4">AK_agg_input_add_to_beginning</a> (<a class="el" href="structAK__header.html">AK_header</a> header, int agg_task, <a class="el" href="structAK__agg__input.html">AK_agg_input</a> *input)</td></tr>
<tr class="memdesc:a3c630754ec1a2714e3b04b5753b2d0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that adds a header with a task on the beginning of the input object for aggregation. With the use of for loop existing attributes and tasks are moved from one place forward in input object.  <a href="aggregation_8c.html#a3c630754ec1a2714e3b04b5753b2d0f4">More...</a><br /></td></tr>
<tr class="separator:a3c630754ec1a2714e3b04b5753b2d0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4852916a839c07af5f820cc9efb2ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aggregation_8c.html#aed4852916a839c07af5f820cc9efb2ba">AK_agg_input_fix</a> (<a class="el" href="structAK__agg__input.html">AK_agg_input</a> *input)</td></tr>
<tr class="memdesc:aed4852916a839c07af5f820cc9efb2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">function that handles AVG (average) aggregation. It goes through array of tasks in input object until it comes to task with a value of -1. While loop examines whether the task in array is equal to AGG_TASK_AVG. If so, AGG_TASK_AVG_COUNT is put on the beginning of input object. After that, AGG_TASK_AVG_SUM is put on the beginning of input object.  <a href="aggregation_8c.html#aed4852916a839c07af5f820cc9efb2ba">More...</a><br /></td></tr>
<tr class="separator:aed4852916a839c07af5f820cc9efb2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09c7d8e90edcda6cd005cdd8d49c34b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aggregation_8c.html#ac09c7d8e90edcda6cd005cdd8d49c34b">AK_aggregation</a> (<a class="el" href="structAK__agg__input.html">AK_agg_input</a> *input, char *source_table, char *agg_table)</td></tr>
<tr class="memdesc:ac09c7d8e90edcda6cd005cdd8d49c34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that aggregates a given table by given attributes. Firstly, AGG_TASK_AVG_COUNT and AGG_TASK_AVG_SUM are put on the beginning of the input object. Then for loop iterates through input tasks and assignes the type of aggregation operation according to aggregation operation. New table has to be created. For loop goes through given table. GROUP operation is executed separately from other operations. Addresses of records are put in needed_values array and results are put in new table.  <a href="aggregation_8c.html#ac09c7d8e90edcda6cd005cdd8d49c34b">More...</a><br /></td></tr>
<tr class="separator:ac09c7d8e90edcda6cd005cdd8d49c34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1e136ef513da3141513f268e493daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTestResult.html">TestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="aggregation_8c.html#afb1e136ef513da3141513f268e493daf">AK_aggregation_test</a> ()</td></tr>
<tr class="separator:afb1e136ef513da3141513f268e493daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides functions for aggregation and grouping </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af98d6f8022efcff9d02f0b8b6f62b646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98d6f8022efcff9d02f0b8b6f62b646">&#9670;&nbsp;</a></span>AK_agg_input_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_agg_input_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a>&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>agg_task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__agg__input.html">AK_agg_input</a> *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that adds a header with a task in input object for aggregation. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Frankovic </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>a header that is being aggregated </td></tr>
    <tr><td class="paramname">agg_task</td><td>the task which is to be done on the header </td></tr>
    <tr><td class="paramname">input</td><td>the input object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns EXIT_SUCCESS, otherwise EXIT_FAILURE </dd></dl>

</div>
</div>
<a id="a3c630754ec1a2714e3b04b5753b2d0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c630754ec1a2714e3b04b5753b2d0f4">&#9670;&nbsp;</a></span>AK_agg_input_add_to_beginning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_agg_input_add_to_beginning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a>&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>agg_task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__agg__input.html">AK_agg_input</a> *&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that adds a header with a task on the beginning of the input object for aggregation. With the use of for loop existing attributes and tasks are moved from one place forward in input object. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Frankovic </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>a header that is being aggregated </td></tr>
    <tr><td class="paramname">agg_task</td><td>the task which is to be done on the header </td></tr>
    <tr><td class="paramname">input</td><td>the input object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns EXIT_SUCCESS, otherwise EXIT_FAILURE </dd></dl>

</div>
</div>
<a id="aed4852916a839c07af5f820cc9efb2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4852916a839c07af5f820cc9efb2ba">&#9670;&nbsp;</a></span>AK_agg_input_fix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_agg_input_fix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__agg__input.html">AK_agg_input</a> *&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function that handles AVG (average) aggregation. It goes through array of tasks in input object until it comes to task with a value of -1. While loop examines whether the task in array is equal to AGG_TASK_AVG. If so, AGG_TASK_AVG_COUNT is put on the beginning of input object. After that, AGG_TASK_AVG_SUM is put on the beginning of input object. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Frankovic </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a id="af8db5150c0790b36ae56526280e47599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8db5150c0790b36ae56526280e47599">&#9670;&nbsp;</a></span>AK_agg_input_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_agg_input_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__agg__input.html">AK_agg_input</a> *&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes the input object for aggregation with init values. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Frankovic </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a id="ac09c7d8e90edcda6cd005cdd8d49c34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09c7d8e90edcda6cd005cdd8d49c34b">&#9670;&nbsp;</a></span>AK_aggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_aggregation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__agg__input.html">AK_agg_input</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>source_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>agg_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that aggregates a given table by given attributes. Firstly, AGG_TASK_AVG_COUNT and AGG_TASK_AVG_SUM are put on the beginning of the input object. Then for loop iterates through input tasks and assignes the type of aggregation operation according to aggregation operation. New table has to be created. For loop goes through given table. GROUP operation is executed separately from other operations. Addresses of records are put in needed_values array and results are put in new table. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Frankovic </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input object with list of atributes by which we aggregate and types of aggregations </td></tr>
    <tr><td class="paramname">source_table</td><td>- table name for the source table </td></tr>
    <tr><td class="paramname">agg_table</td><td>table name for aggregated table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if continues succesfuly, when not EXIT_ERROR </dd></dl>
<p>THIS SINGLE LINE BELOW (memcpy) is the purpose of ALL evil in the world! This line is the reason why test function prints one extra empty row with "nulls" at the end! Trust me! Comment it, and you will see - test function will not print extra row with nulls (but counts and averages in table will be all messed up!) After two days of hard research, I still have not found what is the reason behind printing extra row at the end! Fellow programmer, if you really really want to solve this issue, arm yourself with at least 2 liters of hot coffee!</p>
<p>What this line does? What is the purpose of this line in the universe? Well, fellow programmer, this line sets the initial count to 1. That means if name "Ivan" is found, it will have count of 1 because, well, that's the first Ivan that is found! If function finds another Ivan (which, actually, will happen), this part of code will not handle it (other part of code will).</p>
<p>That actually means that this little piece of code (this line below) only (and ONLY) sets count to 1! And besides that causes every other evil in the world. :O</p>
<p>P.S. The reason for that may be in linked list, or in <a class="el" href="fileio_8c.html#afca67a1ee5ada6576c78b1b88412ac4a" title="Function inserts a one row into table. Firstly it is checked whether inserted row would violite refer...">AK_insert_row()</a> You'll have to check every piece of AKDB code to find cause! I have found out that additional line is added when k == 25. There may be problem in linked lists or in AK_insert_row function or somewhere else. Who knows.</p>
<p>If I didn't handle that last row (which has one attribute of size 0), test would not pass!</p>
<p>Good luck, fellow programmer!</p>

</div>
</div>
<a id="afb1e136ef513da3141513f268e493daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1e136ef513da3141513f268e493daf">&#9670;&nbsp;</a></span>AK_aggregation_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTestResult.html">TestResult</a> AK_aggregation_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>checking results</p>
<p>This variable was added to handle bug described in this file.</p>

</div>
</div>
<a id="abace9faf5a77b69ad08b10086556b47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abace9faf5a77b69ad08b10086556b47b">&#9670;&nbsp;</a></span>AK_header_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_header_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that calculates how many attributes there are in the header with a while loop. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Frankovic </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>A header array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of attributes defined in header array </dd></dl>

</div>
</div>
<a id="a91490139be5ae263a0f79085353929d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91490139be5ae263a0f79085353929d8">&#9670;&nbsp;</a></span>AK_search_unsorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsearch__result.html">search_result</a> AK_search_unsorted </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szRelation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsearch__params.html">search_params</a> *&#160;</td>
          <td class="paramname"><em>aspParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iNum_search_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that searches through unsorted values of multiple attributes in a segment. Only tuples that are equal on all given attribute values are returned (A == 1 AND B == 7 AND ...). SEARCH_RANGE is inclusive. Only one value (or range) per attribute allowed - use <a class="el" href="structsearch__params.html#a061c7b5e9a3163f19dac0d3a681d63d0" title="pointer to lower value of search range">search_params.pData_lower</a> for SEARCH_PARTICULAR. Supported types for SEARCH_RANGE: TYPE_INT, TYPE_FLOAT, TYPE_NUMBER, TYPE_DATE, TYPE_DATETIME, TYPE_TIME. Do not provide the wrong data types in the array of search parameters. There is no way to test for that and it could cause a memory access violation. </p>
<dl class="section author"><dt>Author</dt><dd>Miroslav Policki</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">szRelation</td><td>relation name </td></tr>
    <tr><td class="paramname">aspParams</td><td>array of search parameters </td></tr>
    <tr><td class="paramname">iNum_search_params</td><td>number of search parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structsearch__result.html" title="Structure which represents search result of AK_equisearch_unsorted and AK_rangesearch_unsorted.">search_result</a> structure defined in <a class="el" href="filesearch_8h.html">filesearch.h</a>. Use AK_deallocate_search_result to deallocate. </dd></dl>
<p>iterate through all the blocks</p>
<p>count number of attributes in segment/relation</p>
<p>determine index of attributes on which search will be performed</p>
<p>if any of the provided attributes are not found in the relation, return empty result</p>
<p>in every tuple, for all required attributes, compare attribute value with searched-for value and store matched tuple addresses</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_0b8cd375c317792b95eba87076cd6518.html">rel</a></li><li class="navelem"><a class="el" href="aggregation_8c.html">aggregation.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
