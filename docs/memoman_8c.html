<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kalashnikov DB: mm/memoman.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalashnikov DB
   &#160;<span id="projectnumber">0.9.3</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('memoman_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">memoman.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="memoman_8h_source.html">memoman.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dbman_8h_source.html">../dm/dbman.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for memoman.c:</div>
<div class="dyncontent">
<div class="center"><img src="memoman_8c__incl.png" border="0" usemap="#mm_2memoman_8c" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2317b44ce55736ad837edf3ad71a1c7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a2317b44ce55736ad837edf3ad71a1c7c">AK_cache_block</a> (int num, <a class="el" href="structAK__mem__block.html">AK_mem_block</a> *mem_block)</td></tr>
<tr class="memdesc:a2317b44ce55736ad837edf3ad71a1c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that caches a block into the memory.  <a href="memoman_8c.html#a2317b44ce55736ad837edf3ad71a1c7c">More...</a><br /></td></tr>
<tr class="separator:a2317b44ce55736ad837edf3ad71a1c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8995ab22740ed96890c67a7a35f4abc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a8995ab22740ed96890c67a7a35f4abc0">AK_cache_AK_malloc</a> ()</td></tr>
<tr class="memdesc:a8995ab22740ed96890c67a7a35f4abc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes the global cache memory (variable db_cache)  <a href="memoman_8c.html#a8995ab22740ed96890c67a7a35f4abc0">More...</a><br /></td></tr>
<tr class="separator:a8995ab22740ed96890c67a7a35f4abc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a8b7ffd296d01d9a3ed5de5379250d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a86a8b7ffd296d01d9a3ed5de5379250d">AK_redo_log_AK_malloc</a> ()</td></tr>
<tr class="memdesc:a86a8b7ffd296d01d9a3ed5de5379250d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes the global redo log memory (variable redo_log)  <a href="memoman_8c.html#a86a8b7ffd296d01d9a3ed5de5379250d">More...</a><br /></td></tr>
<tr class="separator:a86a8b7ffd296d01d9a3ed5de5379250d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade99412b4e4a4bf221ed9a530aaf632b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#ade99412b4e4a4bf221ed9a530aaf632b">AK_find_available_result_block</a> ()</td></tr>
<tr class="memdesc:ade99412b4e4a4bf221ed9a530aaf632b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that finds the available block for result caching in a circular array.  <a href="memoman_8c.html#ade99412b4e4a4bf221ed9a530aaf632b">More...</a><br /></td></tr>
<tr class="separator:ade99412b4e4a4bf221ed9a530aaf632b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb21199f31ed38d983992dd22d96e5e9"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#abb21199f31ed38d983992dd22d96e5e9">AK_generate_result_id</a> (unsigned char *str)</td></tr>
<tr class="memdesc:abb21199f31ed38d983992dd22d96e5e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that generates a unique hash identifier for each cached result by using djb2 algorithm.  <a href="memoman_8c.html#abb21199f31ed38d983992dd22d96e5e9">More...</a><br /></td></tr>
<tr class="separator:abb21199f31ed38d983992dd22d96e5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91cae56c46d590937bec5ebe52b5fb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#aa91cae56c46d590937bec5ebe52b5fb6">AK_cache_result</a> (char *srcTable, <a class="el" href="structAK__block.html">AK_block</a> *temp_block, <a class="el" href="structAK__header.html">AK_header</a> header[])</td></tr>
<tr class="memdesc:aa91cae56c46d590937bec5ebe52b5fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that caches the fetched result block in memory.  <a href="memoman_8c.html#aa91cae56c46d590937bec5ebe52b5fb6">More...</a><br /></td></tr>
<tr class="separator:aa91cae56c46d590937bec5ebe52b5fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12abfe4f312e3bf23162a6e46ed11cd3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a12abfe4f312e3bf23162a6e46ed11cd3">AK_query_mem_AK_malloc</a> ()</td></tr>
<tr class="memdesc:a12abfe4f312e3bf23162a6e46ed11cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes the global query memory (variable query_mem)  <a href="memoman_8c.html#a12abfe4f312e3bf23162a6e46ed11cd3">More...</a><br /></td></tr>
<tr class="separator:a12abfe4f312e3bf23162a6e46ed11cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27900c488a29b15b407d6582d9f0d23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#ac27900c488a29b15b407d6582d9f0d23">AK_query_mem_AK_free</a> ()</td></tr>
<tr class="memdesc:ac27900c488a29b15b407d6582d9f0d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that releases the global query memory (variable query_mem)  <a href="memoman_8c.html#ac27900c488a29b15b407d6582d9f0d23">More...</a><br /></td></tr>
<tr class="separator:ac27900c488a29b15b407d6582d9f0d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaacdc6d364a3c59c428e5fa330d7be7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#aaacdc6d364a3c59c428e5fa330d7be7a">AK_memoman_init</a> ()</td></tr>
<tr class="memdesc:aaacdc6d364a3c59c428e5fa330d7be7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes the memory manager (cache, redo log and query memory)  <a href="memoman_8c.html#aaacdc6d364a3c59c428e5fa330d7be7a">More...</a><br /></td></tr>
<tr class="separator:aaacdc6d364a3c59c428e5fa330d7be7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b391872c1c7b90dcefca2e7c1159110"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAK__mem__block.html">AK_mem_block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a6b391872c1c7b90dcefca2e7c1159110">AK_get_block</a> (int num)</td></tr>
<tr class="memdesc:a6b391872c1c7b90dcefca2e7c1159110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads a block from the memory. If the block is cached, returns the cached block. Else uses AK_cache_block to read the block to cache and then returns it.  <a href="memoman_8c.html#a6b391872c1c7b90dcefca2e7c1159110">More...</a><br /></td></tr>
<tr class="separator:a6b391872c1c7b90dcefca2e7c1159110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad333156acd3d5f5713d8c5524fb724a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#ad333156acd3d5f5713d8c5524fb724a8">AK_release_oldest_cache_block</a> ()</td></tr>
<tr class="memdesc:ad333156acd3d5f5713d8c5524fb724a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions that flushes the oldest block to disk and recalculates the next block to remove.  <a href="memoman_8c.html#ad333156acd3d5f5713d8c5524fb724a8">More...</a><br /></td></tr>
<tr class="separator:ad333156acd3d5f5713d8c5524fb724a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffc70a286c879e1feae8c37229a5e14"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a0ffc70a286c879e1feae8c37229a5e14">AK_mem_block_modify</a> (<a class="el" href="structAK__mem__block.html">AK_mem_block</a> *mem_block, int dirty)</td></tr>
<tr class="memdesc:a0ffc70a286c879e1feae8c37229a5e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that modifies the "dirty" bit of a block, and update the timestamps accordingly.  <a href="memoman_8c.html#a0ffc70a286c879e1feae8c37229a5e14">More...</a><br /></td></tr>
<tr class="separator:a0ffc70a286c879e1feae8c37229a5e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2859df8812fd67dba864b998fb845557"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a2859df8812fd67dba864b998fb845557">AK_refresh_cache</a> ()</td></tr>
<tr class="memdesc:a2859df8812fd67dba864b998fb845557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that re-reads all the blocks from the disk.  <a href="memoman_8c.html#a2859df8812fd67dba864b998fb845557">More...</a><br /></td></tr>
<tr class="separator:a2859df8812fd67dba864b998fb845557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8d902fa14040c84e49ddd78ad1594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtable__addresses.html">table_addresses</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#afeb8d902fa14040c84e49ddd78ad1594">AK_get_index_segment_addresses</a> (char *segmentName)</td></tr>
<tr class="memdesc:afeb8d902fa14040c84e49ddd78ad1594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting a index segment address.  <a href="memoman_8c.html#afeb8d902fa14040c84e49ddd78ad1594">More...</a><br /></td></tr>
<tr class="separator:afeb8d902fa14040c84e49ddd78ad1594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e0e529fdca2514e5f0f0bb6f711805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtable__addresses.html">table_addresses</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a43e0e529fdca2514e5f0f0bb6f711805">AK_get_segment_addresses</a> (char *segmentName)</td></tr>
<tr class="memdesc:a43e0e529fdca2514e5f0f0bb6f711805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting a relation segment address.  <a href="memoman_8c.html#a43e0e529fdca2514e5f0f0bb6f711805">More...</a><br /></td></tr>
<tr class="separator:a43e0e529fdca2514e5f0f0bb6f711805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb033d1f307414329e2b5e327204115f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtable__addresses.html">table_addresses</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#aeb033d1f307414329e2b5e327204115f">AK_get_segment_addresses_internal</a> (char *tableName, char *segmentName)</td></tr>
<tr class="memdesc:aeb033d1f307414329e2b5e327204115f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting addresses of some table.  <a href="memoman_8c.html#aeb033d1f307414329e2b5e327204115f">More...</a><br /></td></tr>
<tr class="separator:aeb033d1f307414329e2b5e327204115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4134a4bf1ef16d83969d274c009fb416"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a4134a4bf1ef16d83969d274c009fb416">AK_get_system_table_address</a> (const char *name)</td></tr>
<tr class="memdesc:a4134a4bf1ef16d83969d274c009fb416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that gets the address of a system table by name.  <a href="memoman_8c.html#a4134a4bf1ef16d83969d274c009fb416">More...</a><br /></td></tr>
<tr class="separator:a4134a4bf1ef16d83969d274c009fb416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76376b866e541ab3783f36d3afa49488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtable__addresses.html">table_addresses</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a76376b866e541ab3783f36d3afa49488">AK_get_table_addresses</a> (char *table)</td></tr>
<tr class="memdesc:a76376b866e541ab3783f36d3afa49488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting addresses of some table.  <a href="memoman_8c.html#a76376b866e541ab3783f36d3afa49488">More...</a><br /></td></tr>
<tr class="separator:a76376b866e541ab3783f36d3afa49488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27cfa075e52693d78bf1b1a1e4f8269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtable__addresses.html">table_addresses</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#af27cfa075e52693d78bf1b1a1e4f8269">AK_get_index_addresses</a> (char *index)</td></tr>
<tr class="memdesc:af27cfa075e52693d78bf1b1a1e4f8269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting addresses of some index.  <a href="memoman_8c.html#af27cfa075e52693d78bf1b1a1e4f8269">More...</a><br /></td></tr>
<tr class="separator:af27cfa075e52693d78bf1b1a1e4f8269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1220ee67178ea5e067767ff485c60838"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a1220ee67178ea5e067767ff485c60838">AK_find_AK_free_space</a> (<a class="el" href="structtable__addresses.html">table_addresses</a> *addresses)</td></tr>
<tr class="memdesc:a1220ee67178ea5e067767ff485c60838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that finds AK_free space in some block betwen block addresses. It's made for insert_row()  <a href="memoman_8c.html#a1220ee67178ea5e067767ff485c60838">More...</a><br /></td></tr>
<tr class="separator:a1220ee67178ea5e067767ff485c60838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6979c35f6af3093da999d7d2f82a110d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a6979c35f6af3093da999d7d2f82a110d">AK_init_new_extent</a> (char *table_name, int extent_type)</td></tr>
<tr class="memdesc:a6979c35f6af3093da999d7d2f82a110d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that extends the segment.  <a href="memoman_8c.html#a6979c35f6af3093da999d7d2f82a110d">More...</a><br /></td></tr>
<tr class="separator:a6979c35f6af3093da999d7d2f82a110d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8513b8ebd5d256202d0c4a475f59768"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#ae8513b8ebd5d256202d0c4a475f59768">AK_flush_cache</a> ()</td></tr>
<tr class="memdesc:ae8513b8ebd5d256202d0c4a475f59768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that flushes memory blocks to disk file.  <a href="memoman_8c.html#ae8513b8ebd5d256202d0c4a475f59768">More...</a><br /></td></tr>
<tr class="separator:ae8513b8ebd5d256202d0c4a475f59768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cce5560a3d91368dfc194e6372334dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTestResult.html">TestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a3cce5560a3d91368dfc194e6372334dd">AK_memoman_test</a> ()</td></tr>
<tr class="separator:a3cce5560a3d91368dfc194e6372334dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9bcf0f1e79755d11164309800da41f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTestResult.html">TestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="memoman_8c.html#a8a9bcf0f1e79755d11164309800da41f">AK_memoman_test2</a> ()</td></tr>
<tr class="separator:a8a9bcf0f1e79755d11164309800da41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines functions for the memory manager of Kalashnikov DB </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8995ab22740ed96890c67a7a35f4abc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8995ab22740ed96890c67a7a35f4abc0">&#9670;&nbsp;</a></span>AK_cache_AK_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_cache_AK_malloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes the global cache memory (variable db_cache) </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten, Matija Šestak(revised) </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the cache memory has been initialized, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="a2317b44ce55736ad837edf3ad71a1c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2317b44ce55736ad837edf3ad71a1c7c">&#9670;&nbsp;</a></span>AK_cache_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_cache_block </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__mem__block.html">AK_mem_block</a> *&#160;</td>
          <td class="paramname"><em>mem_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that caches a block into the memory. </p>
<dl class="section author"><dt>Author</dt><dd>Nikola Bakoš, Matija Šestak(revised) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>block number (address) </td></tr>
    <tr><td class="paramname">mem_block</td><td>address of memmory block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the block has been successfully read into memory, EXIT_ERROR otherwise </dd></dl>
<p>read the block from the given address</p>
<p>set dirty bit in mem_block struct</p>
<p>get the timestamp</p>
<p>set timestamp_read</p>
<p>set timestamp_last_change</p>

</div>
</div>
<a id="aa91cae56c46d590937bec5ebe52b5fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91cae56c46d590937bec5ebe52b5fb6">&#9670;&nbsp;</a></span>AK_cache_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_cache_result </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>srcTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>temp_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a>&#160;</td>
          <td class="paramname"><em>header</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that caches the fetched result block in memory. </p>
<dl class="section author"><dt>Author</dt><dd>Mario Novoselec </dd></dl>

</div>
</div>
<a id="a1220ee67178ea5e067767ff485c60838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1220ee67178ea5e067767ff485c60838">&#9670;&nbsp;</a></span>AK_find_AK_free_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_find_AK_free_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtable__addresses.html">table_addresses</a> *&#160;</td>
          <td class="paramname"><em>addresses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that finds AK_free space in some block betwen block addresses. It's made for insert_row() </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, updated by Matija Šestak( function now uses caching) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>addresses of extents </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the block to write in </dd></dl>

</div>
</div>
<a id="ade99412b4e4a4bf221ed9a530aaf632b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade99412b4e4a4bf221ed9a530aaf632b">&#9670;&nbsp;</a></span>AK_find_available_result_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_find_available_result_block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that finds the available block for result caching in a circular array. </p>
<dl class="section author"><dt>Author</dt><dd>Mario Novoselec </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>available_index </dd></dl>

</div>
</div>
<a id="ae8513b8ebd5d256202d0c4a475f59768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8513b8ebd5d256202d0c4a475f59768">&#9670;&nbsp;</a></span>AK_flush_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_flush_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that flushes memory blocks to disk file. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Šestak, updated by Antonio Martinović </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS </dd></dl>
<p>if block form cache can not be writed to DB file -&gt; EXIT_ERROR</p>
<p>block is clean after successfuly writing it to disk</p>

</div>
</div>
<a id="abb21199f31ed38d983992dd22d96e5e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb21199f31ed38d983992dd22d96e5e9">&#9670;&nbsp;</a></span>AK_generate_result_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long AK_generate_result_id </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that generates a unique hash identifier for each cached result by using djb2 algorithm. </p>
<dl class="section author"><dt>Author</dt><dd>Mario Novoselec </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>hash </dd></dl>

</div>
</div>
<a id="a6b391872c1c7b90dcefca2e7c1159110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b391872c1c7b90dcefca2e7c1159110">&#9670;&nbsp;</a></span>AK_get_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAK__mem__block.html">AK_mem_block</a>* AK_get_block </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads a block from the memory. If the block is cached, returns the cached block. Else uses AK_cache_block to read the block to cache and then returns it. </p>
<dl class="section author"><dt>Author</dt><dd>Tomislav Fotak, updated by Matija Šestak, Antonio Martinović </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>block number (address) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>segment start address </dd></dl>
<p>found cached! we're done here</p>
<p>while looking for block we also want to find an empty block in case that the actual block is not found then there is no need to run through the blocks twice</p>
<p>created new cache block for specified address</p>
<p>no free cache blocks found, we need to clear some now</p>
<p>no cache for you</p>

</div>
</div>
<a id="af27cfa075e52693d78bf1b1a1e4f8269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27cfa075e52693d78bf1b1a1e4f8269">&#9670;&nbsp;</a></span>AK_get_index_addresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtable__addresses.html">table_addresses</a>* AK_get_index_addresses </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting addresses of some index. </p>
<dl class="section author"><dt>Author</dt><dd>Mislav Čakarić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index name that you search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>structure <a class="el" href="structtable__addresses.html" title="Structure that defines start and end address of extent.">table_addresses</a> witch contains start and end adresses of table extents, when form and to are 0 you are on the end of addresses </dd></dl>

</div>
</div>
<a id="afeb8d902fa14040c84e49ddd78ad1594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8d902fa14040c84e49ddd78ad1594">&#9670;&nbsp;</a></span>AK_get_index_segment_addresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtable__addresses.html">table_addresses</a>* AK_get_index_segment_addresses </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>segmentName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting a index segment address. </p>
<p>@Author Antonio Martinović </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentName</td><td>table name that you search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>structure <a class="el" href="structtable__addresses.html" title="Structure that defines start and end address of extent.">table_addresses</a> witch contains start and end adresses of table extents, when form and to are 0 you are on the end of addresses </dd></dl>

</div>
</div>
<a id="a43e0e529fdca2514e5f0f0bb6f711805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e0e529fdca2514e5f0f0bb6f711805">&#9670;&nbsp;</a></span>AK_get_segment_addresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtable__addresses.html">table_addresses</a>* AK_get_segment_addresses </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>segmentName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting a relation segment address. </p>
<p>Function for getting a index segment address.</p>
<p>@Author Antonio Martinović </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segmentName</td><td>table name that you search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>structure <a class="el" href="structtable__addresses.html" title="Structure that defines start and end address of extent.">table_addresses</a> witch contains start and end adresses of table extents, when form and to are 0 you are on the end of addresses </dd></dl>

</div>
</div>
<a id="aeb033d1f307414329e2b5e327204115f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb033d1f307414329e2b5e327204115f">&#9670;&nbsp;</a></span>AK_get_segment_addresses_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtable__addresses.html">table_addresses</a>* AK_get_segment_addresses_internal </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tableName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>segmentName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting addresses of some table. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, updated by Matija Šestak, Mislav Čakarić, Antonio Martinović </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tableName</td><td>table name that you search for </td></tr>
    <tr><td class="paramname">segmentName</td><td>segment name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>structure <a class="el" href="structtable__addresses.html" title="Structure that defines start and end address of extent.">table_addresses</a> witch contains start and end adresses of table extents, when form and to are 0 you are on the end of addresses </dd></dl>

</div>
</div>
<a id="a4134a4bf1ef16d83969d274c009fb416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4134a4bf1ef16d83969d274c009fb416">&#9670;&nbsp;</a></span>AK_get_system_table_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_get_system_table_address </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that gets the address of a system table by name. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak, updated by Matija Šestak, Mislav Čakarić, Antonio Martinović </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>of system table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>table address </dd></dl>

</div>
</div>
<a id="a76376b866e541ab3783f36d3afa49488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76376b866e541ab3783f36d3afa49488">&#9670;&nbsp;</a></span>AK_get_table_addresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtable__addresses.html">table_addresses</a>* AK_get_table_addresses </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting addresses of some table. </p>
<dl class="section author"><dt>Author</dt><dd>Mislav Čakarić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>table name that you search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>structure <a class="el" href="structtable__addresses.html" title="Structure that defines start and end address of extent.">table_addresses</a> witch contains start and end adresses of table extents, when form and to are 0 you are on the end of addresses </dd></dl>

</div>
</div>
<a id="a6979c35f6af3093da999d7d2f82a110d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6979c35f6af3093da999d7d2f82a110d">&#9670;&nbsp;</a></span>AK_init_new_extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_new_extent </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extent_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that extends the segment. </p>
<dl class="section author"><dt>Author</dt><dd>Nikola Bakoš, updated by Matija Šestak (function now uses caching), updated by Mislav Čakarić, updated by Dino Laktašić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table_name</td><td>name of segment to extent </td></tr>
    <tr><td class="paramname">extent_type</td><td>type of extent (can be one of: SEGMENT_TYPE_SYSTEM_TABLE, SEGMENT_TYPE_TABLE, SEGMENT_TYPE_INDEX, SEGMENT_TYPE_TRANSACTION, SEGMENT_TYPE_TEMP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of new extent, otherwise EXIT_ERROR </dd></dl>
<p>!! to correct header BUG iterate through header from 0 to N-th block while there is</p>

</div>
</div>
<a id="a0ffc70a286c879e1feae8c37229a5e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffc70a286c879e1feae8c37229a5e14">&#9670;&nbsp;</a></span>AK_mem_block_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_mem_block_modify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__mem__block.html">AK_mem_block</a> *&#160;</td>
          <td class="paramname"><em>mem_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dirty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that modifies the "dirty" bit of a block, and update the timestamps accordingly. </p>
<dl class="section author"><dt>Author</dt><dd>Alen Novosel. </dd></dl>

</div>
</div>
<a id="aaacdc6d364a3c59c428e5fa330d7be7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacdc6d364a3c59c428e5fa330d7be7a">&#9670;&nbsp;</a></span>AK_memoman_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_memoman_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes the memory manager (cache, redo log and query memory) </p>
<dl class="section author"><dt>Author</dt><dd>Miroslav Policki </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the query memory manager has been initialized, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="a3cce5560a3d91368dfc194e6372334dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cce5560a3d91368dfc194e6372334dd">&#9670;&nbsp;</a></span>AK_memoman_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTestResult.html">TestResult</a> AK_memoman_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a9bcf0f1e79755d11164309800da41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9bcf0f1e79755d11164309800da41f">&#9670;&nbsp;</a></span>AK_memoman_test2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTestResult.html">TestResult</a> AK_memoman_test2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac27900c488a29b15b407d6582d9f0d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27900c488a29b15b407d6582d9f0d23">&#9670;&nbsp;</a></span>AK_query_mem_AK_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_query_mem_AK_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that releases the global query memory (variable query_mem) </p>
<dl class="section author"><dt>Author</dt><dd>Elvis Popović </dd></dl>

</div>
</div>
<a id="a12abfe4f312e3bf23162a6e46ed11cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12abfe4f312e3bf23162a6e46ed11cd3">&#9670;&nbsp;</a></span>AK_query_mem_AK_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_query_mem_AK_malloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes the global query memory (variable query_mem) </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the query memory has been initialized, EXIT_ERROR otherwise </dd></dl>
<p>allocate memory for global variable query_mem</p>
<p>allocate memory for variable query_mem_lib which is used in query_mem-&gt;parsed</p>
<p>allocate memory for variable query_mem_dict which is used in query_mem-&gt;dictionary</p>
<p>allocate memory for variable query_mem_result which is used in query_mem-&gt;result</p>

</div>
</div>
<a id="a86a8b7ffd296d01d9a3ed5de5379250d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a8b7ffd296d01d9a3ed5de5379250d">&#9670;&nbsp;</a></span>AK_redo_log_AK_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_redo_log_AK_malloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes the global redo log memory (variable redo_log) </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Sambolić updated by Dražen Bandić, updated by Tomislav Turek </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the redo log memory has been initialized, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="a2859df8812fd67dba864b998fb845557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2859df8812fd67dba864b998fb845557">&#9670;&nbsp;</a></span>AK_refresh_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_refresh_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that re-reads all the blocks from the disk. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Šestak. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS </dd></dl>

</div>
</div>
<a id="ad333156acd3d5f5713d8c5524fb724a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad333156acd3d5f5713d8c5524fb724a8">&#9670;&nbsp;</a></span>AK_release_oldest_cache_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_release_oldest_cache_block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functions that flushes the oldest block to disk and recalculates the next block to remove. </p>
<dl class="section author"><dt>Author</dt><dd>Antonio Martinović </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>index of flushed cache block </dd></dl>
<p>if block form cache can not be writed to DB file -&gt; EXIT_ERROR</p>
<p>block is clean after successfuly writing it to disk</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_fc11452e4696bd8c0943c731770ef0fd.html">mm</a></li><li class="navelem"><a class="el" href="memoman_8c.html">memoman.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
