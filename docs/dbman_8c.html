<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kalashnikov DB: dm/dbman.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kalashnikov DB
   &#160;<span id="projectnumber">0.9.3</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dbman_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">dbman.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="dbman_8h_source.html">dbman.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memoman_8h_source.html">../mm/memoman.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for dbman.c:</div>
<div class="dyncontent">
<div class="center"><img src="dbman_8c__incl.png" border="0" usemap="#dm_2dbman_8c" alt=""/></div>
<!-- MAP 0 -->
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7cacca7e9aebff2aee36f85632e5c35e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a7cacca7e9aebff2aee36f85632e5c35e">AK_init_db_file</a> (int size)</td></tr>
<tr class="memdesc:a7cacca7e9aebff2aee36f85632e5c35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes a new database file named DB_FILE. It opens database file. New block is allocated. In this block type of header is set to FREE_INT, attribute names are set to FREE_CHAR, integrities are set to FREE_INT, constraint names are set to FREE_CHAR, constraint names and codes are set to FREE_CHAR. Type, address and size of tuples are set to FREE_INT. Data in block is set to FREE_CHAR. Type of block is BLOCK_TYPE_FREE, it is not chained and id of last tuple is 0.  <a href="dbman_8c.html#a7cacca7e9aebff2aee36f85632e5c35e">More...</a><br /></td></tr>
<tr class="separator:a7cacca7e9aebff2aee36f85632e5c35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e85dd0d7290cf56aa9ef24070cea0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a05e85dd0d7290cf56aa9ef24070cea0a">AK_get_allocation_set</a> (int *allocationSet, int fromWhere, int gaplength, int numRequestedBlocks, <a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a> mode, int target)</td></tr>
<tr class="memdesc:a05e85dd0d7290cf56aa9ef24070cea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function prepare demanded sets from allocation table.  <a href="dbman_8c.html#a05e85dd0d7290cf56aa9ef24070cea0a">More...</a><br /></td></tr>
<tr class="separator:a05e85dd0d7290cf56aa9ef24070cea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef840915c467e6b1bc49a3326986763f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#aef840915c467e6b1bc49a3326986763f">AK_allocationtable_dump</a> (int verbosity)</td></tr>
<tr class="memdesc:aef840915c467e6b1bc49a3326986763f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the allocation table from the global allocation bit-vector onto standard output.  <a href="dbman_8c.html#aef840915c467e6b1bc49a3326986763f">More...</a><br /></td></tr>
<tr class="separator:aef840915c467e6b1bc49a3326986763f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cc1bf5140ec26eebb866476e275838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a56cc1bf5140ec26eebb866476e275838">AK_blocktable_dump</a> (int verbosity)</td></tr>
<tr class="memdesc:a56cc1bf5140ec26eebb866476e275838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps the bit-table from the global allocation bit-vector onto standard output.  <a href="dbman_8c.html#a56cc1bf5140ec26eebb866476e275838">More...</a><br /></td></tr>
<tr class="separator:a56cc1bf5140ec26eebb866476e275838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4ddae5253862ad465b91b1e940a71f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#aef4ddae5253862ad465b91b1e940a71f">AK_blocktable_flush</a> ()</td></tr>
<tr class="memdesc:aef4ddae5253862ad465b91b1e940a71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function flushes bitmask table to the disk.  <a href="dbman_8c.html#aef4ddae5253862ad465b91b1e940a71f">More...</a><br /></td></tr>
<tr class="separator:aef4ddae5253862ad465b91b1e940a71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a5fe4ed50be350e3c9d9d20a57afbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#ab4a5fe4ed50be350e3c9d9d20a57afbe">AK_allocate_block_activity_modes</a> ()</td></tr>
<tr class="memdesc:ab4a5fe4ed50be350e3c9d9d20a57afbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation of an array which will contain information about which blocks are being accessed. Creates an array. Each element of this array will correspond to one initialized block. For more info, see explanation in <a class="el" href="dbman_8h.html">dbman.h</a>.  <a href="dbman_8c.html#ab4a5fe4ed50be350e3c9d9d20a57afbe">More...</a><br /></td></tr>
<tr class="separator:ab4a5fe4ed50be350e3c9d9d20a57afbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfd5252c0eed066034b558df30cc790"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#adcfd5252c0eed066034b558df30cc790">AK_blocktable_get</a> ()</td></tr>
<tr class="memdesc:adcfd5252c0eed066034b558df30cc790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets allocation table from the disk.  <a href="dbman_8c.html#adcfd5252c0eed066034b558df30cc790">More...</a><br /></td></tr>
<tr class="separator:adcfd5252c0eed066034b558df30cc790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc6978517271fbd48a004cb039ac6c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#adbc6978517271fbd48a004cb039ac6c1">fsize</a> (FILE *fp)</td></tr>
<tr class="memdesc:adbc6978517271fbd48a004cb039ac6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to determine file size.  <a href="dbman_8c.html#adbc6978517271fbd48a004cb039ac6c1">More...</a><br /></td></tr>
<tr class="separator:adbc6978517271fbd48a004cb039ac6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0b4429858370953a410c6fb5b9ec92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#aee0b4429858370953a410c6fb5b9ec92">AK_init_allocation_table</a> ()</td></tr>
<tr class="memdesc:aee0b4429858370953a410c6fb5b9ec92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes the allocation table, writes it to the disk and caches it in memory.  <a href="dbman_8c.html#aee0b4429858370953a410c6fb5b9ec92">More...</a><br /></td></tr>
<tr class="separator:aee0b4429858370953a410c6fb5b9ec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402f984ce7298e193a2a9c5dc5d6b901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a402f984ce7298e193a2a9c5dc5d6b901">AK_init_block</a> ()</td></tr>
<tr class="memdesc:a402f984ce7298e193a2a9c5dc5d6b901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes new block.  <a href="dbman_8c.html#a402f984ce7298e193a2a9c5dc5d6b901">More...</a><br /></td></tr>
<tr class="separator:a402f984ce7298e193a2a9c5dc5d6b901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcca519b1dbe309c683d64b0e955dca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a3fcca519b1dbe309c683d64b0e955dca">AK_print_block</a> (<a class="el" href="structAK__block.html">AK_block</a> *block, int num, char *gg, FILE *fpp)</td></tr>
<tr class="memdesc:a3fcca519b1dbe309c683d64b0e955dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that dumps a block.  <a href="dbman_8c.html#a3fcca519b1dbe309c683d64b0e955dca">More...</a><br /></td></tr>
<tr class="separator:a3fcca519b1dbe309c683d64b0e955dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48b8ab357cefa4ffcc54c348571c1fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#ac48b8ab357cefa4ffcc54c348571c1fe">AK_allocate_blocks</a> (FILE *<a class="el" href="dbman_8h.html#a89a7f6028a19c3dc081cc5f16eb53891">db</a>, <a class="el" href="structAK__block.html">AK_block</a> *block, int FromWhere, int HowMany)</td></tr>
<tr class="memdesc:ac48b8ab357cefa4ffcc54c348571c1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that allocates new blocks by placing them to appropriate place and then updates the last initialized index.  <a href="dbman_8c.html#ac48b8ab357cefa4ffcc54c348571c1fe">More...</a><br /></td></tr>
<tr class="separator:ac48b8ab357cefa4ffcc54c348571c1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c880db7cf4f8332ae7e93c6b71cc911"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a2c880db7cf4f8332ae7e93c6b71cc911">AK_read_block</a> (int address)</td></tr>
<tr class="memdesc:a2c880db7cf4f8332ae7e93c6b71cc911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads a block at a given address (block number less than db_file_size). New block is allocated. Database file is opened. Position is set to provided address block. At the end function reads file from that position. Completely thread-safe.  <a href="dbman_8c.html#a2c880db7cf4f8332ae7e93c6b71cc911">More...</a><br /></td></tr>
<tr class="separator:a2c880db7cf4f8332ae7e93c6b71cc911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222ea31aa276d52e464137a3b144f78a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a222ea31aa276d52e464137a3b144f78a">AK_write_block</a> (<a class="el" href="structAK__block.html">AK_block</a> *block)</td></tr>
<tr class="memdesc:a222ea31aa276d52e464137a3b144f78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes a block to the DB file. Database file is opened. Position is set to provided address block. Block is written to provided address. Completely thread-safe.  <a href="dbman_8c.html#a222ea31aa276d52e464137a3b144f78a">More...</a><br /></td></tr>
<tr class="separator:a222ea31aa276d52e464137a3b144f78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65d6dc08f264590c53f6f1b0170a21d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#ad65d6dc08f264590c53f6f1b0170a21d">AK_copy_header</a> (<a class="el" href="structAK__header.html">AK_header</a> *header, int *blockSet, int blockSetSize)</td></tr>
<tr class="memdesc:ad65d6dc08f264590c53f6f1b0170a21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function copy header to blocks. Completely thread-safe.  <a href="dbman_8c.html#ad65d6dc08f264590c53f6f1b0170a21d">More...</a><br /></td></tr>
<tr class="separator:ad65d6dc08f264590c53f6f1b0170a21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9525b11c47b5825abb4956add526623c"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a9525b11c47b5825abb4956add526623c">AK_get_extent</a> (int start_address, int desired_size, <a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a> *mode, int border, int target, <a class="el" href="structAK__header.html">AK_header</a> *header, int gl)</td></tr>
<tr class="memdesc:a9525b11c47b5825abb4956add526623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that allocates new extent of blocks. Number of blocks is not ordered as well as a way of search for them.  <a href="dbman_8c.html#a9525b11c47b5825abb4956add526623c">More...</a><br /></td></tr>
<tr class="separator:a9525b11c47b5825abb4956add526623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9411aae916046fdd8e53ed1760a58b6d"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a9411aae916046fdd8e53ed1760a58b6d">AK_increase_extent</a> (int start_address, int add_size, <a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a> *mode, int border, int target, <a class="el" href="structAK__header.html">AK_header</a> *header, int gl)</td></tr>
<tr class="memdesc:a9411aae916046fdd8e53ed1760a58b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that allocates a new blocks for increasing extent size.  <a href="dbman_8c.html#a9411aae916046fdd8e53ed1760a58b6d">More...</a><br /></td></tr>
<tr class="separator:a9411aae916046fdd8e53ed1760a58b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff7d6ea92a45cda91ff2063043900a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a1ff7d6ea92a45cda91ff2063043900a1">AK_new_extent</a> (int start_address, int old_size, int extent_type, <a class="el" href="structAK__header.html">AK_header</a> *header)</td></tr>
<tr class="memdesc:a1ff7d6ea92a45cda91ff2063043900a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that allocates new extent of blocks. If argument "old_size" is 0 than size of extent is INITIAL_EXTENT_SIZE. Otherwise, resize factor is set according to type of extent. If writing of block is successful, number of blocks is incremented.  <a href="dbman_8c.html#a1ff7d6ea92a45cda91ff2063043900a1">More...</a><br /></td></tr>
<tr class="separator:a1ff7d6ea92a45cda91ff2063043900a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e7998e69e2910528f7ef258469b2be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a79e7998e69e2910528f7ef258469b2be">AK_new_segment</a> (char *name, int type, <a class="el" href="structAK__header.html">AK_header</a> *header)</td></tr>
<tr class="memdesc:a79e7998e69e2910528f7ef258469b2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that allocates new segment of extents. In this phase of implementation, only extents containing INITIAL_EXTENT_SIZE blocks can be allocated. If extent is successfully allocated, number of allocated extents is incremented and function goes to next block after allocated extent. Otherwise, function moves to INITIAL_EXTENT_SIZE blocks. In that way function gets either first block of new extent or some block in that extent which will not be AK_free.  <a href="dbman_8c.html#a79e7998e69e2910528f7ef258469b2be">More...</a><br /></td></tr>
<tr class="separator:a79e7998e69e2910528f7ef258469b2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6c8aa698d310cc8eae92ee05e3918b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a2d6c8aa698d310cc8eae92ee05e3918b">AK_create_header</a> (char *attribute_name, int type, int integrity, char *constr_name, char *contr_code)</td></tr>
<tr class="memdesc:a2d6c8aa698d310cc8eae92ee05e3918b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that creates header and initalize integrity, constraint name and constraint code with parameter values of function.  <a href="dbman_8c.html#a2d6c8aa698d310cc8eae92ee05e3918b">More...</a><br /></td></tr>
<tr class="separator:a2d6c8aa698d310cc8eae92ee05e3918b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f011234546a9f1cc751a0d08036b131"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a0f011234546a9f1cc751a0d08036b131">AK_insert_entry</a> (<a class="el" href="structAK__block.html">AK_block</a> *block_address, int type, void *entry_data, int i)</td></tr>
<tr class="memdesc:a0f011234546a9f1cc751a0d08036b131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that inserts an entry in tuple_dict and data of a block. Address, type and size of catalog_tuple_dict are set. Free space of block is also set.  <a href="dbman_8c.html#a0f011234546a9f1cc751a0d08036b131">More...</a><br /></td></tr>
<tr class="separator:a0f011234546a9f1cc751a0d08036b131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48430852cddc2cc7b79dd2775212b10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#ac48430852cddc2cc7b79dd2775212b10">AK_init_system_tables_catalog</a> (int relation, int attribute, int index, int view, int sequence, int function, int function_arguments, int trigger, int trigger_conditions, int <a class="el" href="dbman_8h.html#a89a7f6028a19c3dc081cc5f16eb53891">db</a>, int db_obj, int user, int group, int user_group, int user_right, int group_right, int constraint, int constraintNull, int constraintCheck, int constraintUnique, int reference)</td></tr>
<tr class="memdesc:ac48430852cddc2cc7b79dd2775212b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initialises the sytem table catalog and writes the result in first (0) block in db_file. Catalog block, catalog header name, catalog header address are allocated. Address, type, chained_with and AK_free_space attributes are initialized. Names of various database elements are written in block.  <a href="dbman_8c.html#ac48430852cddc2cc7b79dd2775212b10">More...</a><br /></td></tr>
<tr class="separator:ac48430852cddc2cc7b79dd2775212b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3157bc3da79c19192a915acc1235bad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a3157bc3da79c19192a915acc1235bad0">AK_memset_int</a> (void *block, int value, size_t num)</td></tr>
<tr class="memdesc:a3157bc3da79c19192a915acc1235bad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that sets the first num ints of a block of memory to the specified value.  <a href="dbman_8c.html#a3157bc3da79c19192a915acc1235bad0">More...</a><br /></td></tr>
<tr class="separator:a3157bc3da79c19192a915acc1235bad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c050534ddf6dcf1cba09987424ff76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#af4c050534ddf6dcf1cba09987424ff76">AK_register_system_tables</a> (int relation, int attribute, int index, int view, int sequence, int function, int function_arguments, int trigger, int trigger_conditions, int <a class="el" href="dbman_8h.html#a89a7f6028a19c3dc081cc5f16eb53891">db</a>, int db_obj, int user, int group, int user_group, int user_right, int group_right, int constraint, int constraintNull, int constraintCheck, int constraintUnique, int reference)</td></tr>
<tr class="memdesc:af4c050534ddf6dcf1cba09987424ff76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that registers system tables. Block at the given address is read. Various data from function arguments are written in block about different database elements.  <a href="dbman_8c.html#af4c050534ddf6dcf1cba09987424ff76">More...</a><br /></td></tr>
<tr class="separator:af4c050534ddf6dcf1cba09987424ff76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99cdc5c8456ad5ff87fb542d030c4d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#af99cdc5c8456ad5ff87fb542d030c4d6">AK_init_system_catalog</a> ()</td></tr>
<tr class="memdesc:af99cdc5c8456ad5ff87fb542d030c4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that initializes the system catalog. Headers for system tables are defined. Segments for those system tables are allocated. Above function <a class="el" href="dbman_8c.html#af4c050534ddf6dcf1cba09987424ff76" title="Function that registers system tables. Block at the given address is read. Various data from function...">AK_register_system_tables()</a> to register system tables.  <a href="dbman_8c.html#af99cdc5c8456ad5ff87fb542d030c4d6">More...</a><br /></td></tr>
<tr class="separator:af99cdc5c8456ad5ff87fb542d030c4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5058a1dd8adfdd5663626492f1d1f257"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a5058a1dd8adfdd5663626492f1d1f257">AK_delete_block</a> (int address)</td></tr>
<tr class="memdesc:a5058a1dd8adfdd5663626492f1d1f257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that deletes a block by a given block address (resets the header and data). Types, integrities, constraint names, constraint codes are set to "AK_free" values. In tuple dictionary type, address and size are set to FREE_INT values. Data of block is set to FREE_CHAR.  <a href="dbman_8c.html#a5058a1dd8adfdd5663626492f1d1f257">More...</a><br /></td></tr>
<tr class="separator:a5058a1dd8adfdd5663626492f1d1f257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0ef3161f926bef80f12aa4e0905acd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a1c0ef3161f926bef80f12aa4e0905acd">AK_delete_extent</a> (int begin, int end)</td></tr>
<tr class="memdesc:a1c0ef3161f926bef80f12aa4e0905acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that deletes an extent between the first and the last block.  <a href="dbman_8c.html#a1c0ef3161f926bef80f12aa4e0905acd">More...</a><br /></td></tr>
<tr class="separator:a1c0ef3161f926bef80f12aa4e0905acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6e9ee9800548168a235c26fcceba71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a0a6e9ee9800548168a235c26fcceba71">AK_delete_segment</a> (char *name, int type)</td></tr>
<tr class="separator:a0a6e9ee9800548168a235c26fcceba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7d6a4c56ce0c15b59217a3607db06e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a7e7d6a4c56ce0c15b59217a3607db06e">AK_init_disk_manager</a> ()</td></tr>
<tr class="separator:a7e7d6a4c56ce0c15b59217a3607db06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015e58604332a2a00c0f3998d74db0b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTestResult.html">TestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a015e58604332a2a00c0f3998d74db0b7">AK_allocationbit_test</a> ()</td></tr>
<tr class="separator:a015e58604332a2a00c0f3998d74db0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee317159f91774d2b717a9d2be9ddfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTestResult.html">TestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#aaee317159f91774d2b717a9d2be9ddfc">AK_allocationtable_test</a> ()</td></tr>
<tr class="separator:aaee317159f91774d2b717a9d2be9ddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8396012164fedd2cfae7bf6f6ae0cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTestResult.html">TestResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a9e8396012164fedd2cfae7bf6f6ae0cc">AK_thread_safe_block_access_test</a> ()</td></tr>
<tr class="memdesc:a9e8396012164fedd2cfae7bf6f6ae0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function tests thread safe reading and writing to blocks. There is N writing and N reading threads, which are going through iterations. Each reading thread should read the data (character) that was set by last writing thread.  <a href="dbman_8c.html#a9e8396012164fedd2cfae7bf6f6ae0cc">More...</a><br /></td></tr>
<tr class="separator:a9e8396012164fedd2cfae7bf6f6ae0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5499694bd97b104560d14ef70abe2c73"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a5499694bd97b104560d14ef70abe2c73">AK_read_block_for_testing</a> (void *address)</td></tr>
<tr class="memdesc:a5499694bd97b104560d14ef70abe2c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is only for testing. It has to be there, because pthread_create only accepts void* function_name (void *) function format. So AK_read_block is no-go for pthread_create.  <a href="dbman_8c.html#a5499694bd97b104560d14ef70abe2c73">More...</a><br /></td></tr>
<tr class="separator:a5499694bd97b104560d14ef70abe2c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0558e034eeed865a1c855de5cfad20ef"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a0558e034eeed865a1c855de5cfad20ef">AK_write_block_for_testing</a> (void *block)</td></tr>
<tr class="memdesc:a0558e034eeed865a1c855de5cfad20ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is only for testing. It has to be there, because pthread_create only accepts void* function_name (void *) function format. So AK_write_block is no-go for pthread_create.  <a href="dbman_8c.html#a0558e034eeed865a1c855de5cfad20ef">More...</a><br /></td></tr>
<tr class="separator:a0558e034eeed865a1c855de5cfad20ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa74b62e850a091e2305da8dc8ab1e1de"><td class="memItemLeft" align="right" valign="top">pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#aa74b62e850a091e2305da8dc8ab1e1de">fileLockMutex</a> = PTHREAD_MUTEX_INITIALIZER</td></tr>
<tr class="separator:aa74b62e850a091e2305da8dc8ab1e1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d8194a70159d3603f73699e7f1ed6f"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#a75d8194a70159d3603f73699e7f1ed6f">test_lastCharacterWritten</a> = '\0'</td></tr>
<tr class="memdesc:a75d8194a70159d3603f73699e7f1ed6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable is used only when TEST_MODE is ON! It is used only for testing functionality of <a class="el" href="dbman_8c.html#a9e8396012164fedd2cfae7bf6f6ae0cc" title="This function tests thread safe reading and writing to blocks. There is N writing and N reading threa...">AK_thread_safe_block_access_test()</a> function. It will contain first character of last written block. When reading thread reads the block (written by some other thread), it will compare the first character from this block to character containted in this wariables. If they don't match, then the error occured! It is assumed that the same block is being written to and read from (just like AK_thread_safe_block_access_test function works!)  <a href="dbman_8c.html#a75d8194a70159d3603f73699e7f1ed6f">More...</a><br /></td></tr>
<tr class="separator:a75d8194a70159d3603f73699e7f1ed6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8ef161a5a8600479cc77f15d7b859e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dbman_8c.html#aef8ef161a5a8600479cc77f15d7b859e">test_threadSafeBlockAccessSucceeded</a> = 1</td></tr>
<tr class="memdesc:aef8ef161a5a8600479cc77f15d7b859e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in combination with test_lastCharacterWritten. Will give the answer to question: "Has AK_thread_safe_block_access_test suceeded?" 0 means NO, 1 means YES.  <a href="dbman_8c.html#aef8ef161a5a8600479cc77f15d7b859e">More...</a><br /></td></tr>
<tr class="separator:aef8ef161a5a8600479cc77f15d7b859e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines functions for the disk manager </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab4a5fe4ed50be350e3c9d9d20a57afbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a5fe4ed50be350e3c9d9d20a57afbe">&#9670;&nbsp;</a></span>AK_allocate_block_activity_modes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_allocate_block_activity_modes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocation of an array which will contain information about which blocks are being accessed. Creates an array. Each element of this array will correspond to one initialized block. For more info, see explanation in <a class="el" href="dbman_8h.html">dbman.h</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Domagoj Šitum </dd></dl>

</div>
</div>
<a id="ac48b8ab357cefa4ffcc54c348571c1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48b8ab357cefa4ffcc54c348571c1fe">&#9670;&nbsp;</a></span>AK_allocate_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_allocate_blocks </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>FromWhere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>HowMany</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that allocates new blocks by placing them to appropriate place and then updates the last initialized index. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten , rearranged by dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the file has been written to disk, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="a015e58604332a2a00c0f3998d74db0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015e58604332a2a00c0f3998d74db0b7">&#9670;&nbsp;</a></span>AK_allocationbit_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTestResult.html">TestResult</a> AK_allocationbit_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef840915c467e6b1bc49a3326986763f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef840915c467e6b1bc49a3326986763f">&#9670;&nbsp;</a></span>AK_allocationtable_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_allocationtable_dump </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps the allocation table from the global allocation bit-vector onto standard output. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbosity</td><td>level of verbosity (1 - minimal, 0 - no output) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaee317159f91774d2b717a9d2be9ddfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee317159f91774d2b717a9d2be9ddfc">&#9670;&nbsp;</a></span>AK_allocationtable_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTestResult.html">TestResult</a> AK_allocationtable_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56cc1bf5140ec26eebb866476e275838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cc1bf5140ec26eebb866476e275838">&#9670;&nbsp;</a></span>AK_blocktable_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_blocktable_dump </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps the bit-table from the global allocation bit-vector onto standard output. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbosity</td><td>level of verbosity (1 - verbose, 0 - minimal) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef4ddae5253862ad465b91b1e940a71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4ddae5253862ad465b91b1e940a71f">&#9670;&nbsp;</a></span>AK_blocktable_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_blocktable_flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function flushes bitmask table to the disk. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the file has been written to the disk, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="adcfd5252c0eed066034b558df30cc790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcfd5252c0eed066034b558df30cc790">&#9670;&nbsp;</a></span>AK_blocktable_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_blocktable_get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets allocation table from the disk. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the file has been taken from disk, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="ad65d6dc08f264590c53f6f1b0170a21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65d6dc08f264590c53f6f1b0170a21d">&#9670;&nbsp;</a></span>AK_copy_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_copy_header </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>blockSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockSetSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function copy header to blocks. Completely thread-safe. </p>
<dl class="section author"><dt>Author</dt><dd>Nikola Bakoš, updated by Dino Laktašić (fixed header BUG), refurbished by dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>Pointer to header which will be copied into each block in blockSet </td></tr>
    <tr><td class="paramname">blockSet</td><td>Pointer to array of block addresses into which to copy header </td></tr>
    <tr><td class="paramname">blockSetSize</td><td>Number of blocks in blockSet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of performed header copy </dd></dl>

</div>
</div>
<a id="a2d6c8aa698d310cc8eae92ee05e3918b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6c8aa698d310cc8eae92ee05e3918b">&#9670;&nbsp;</a></span>AK_create_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAK__header.html">AK_header</a>* AK_create_header </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>attribute_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>integrity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>constr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>contr_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that creates header and initalize integrity, constraint name and constraint code with parameter values of function. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the atribute </td></tr>
    <tr><td class="paramname">type</td><td>type of the atribute </td></tr>
    <tr><td class="paramname">integrity</td><td>standard integrity costraint </td></tr>
    <tr><td class="paramname">constr_name</td><td>extra integrity constraint name </td></tr>
    <tr><td class="paramname">contr_code</td><td>extra integrity costraint code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structAK__header.html" title="Structure that represents header structure of blocks (describes an attribute inside an object)....">AK_header</a> </dd></dl>

</div>
</div>
<a id="a5058a1dd8adfdd5663626492f1d1f257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5058a1dd8adfdd5663626492f1d1f257">&#9670;&nbsp;</a></span>AK_delete_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_delete_block </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that deletes a block by a given block address (resets the header and data). Types, integrities, constraint names, constraint codes are set to "AK_free" values. In tuple dictionary type, address and size are set to FREE_INT values. Data of block is set to FREE_CHAR. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>address of the block to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns EXIT_SUCCESS if deletion successful, else EXIT_ERROR </dd></dl>

</div>
</div>
<a id="a1c0ef3161f926bef80f12aa4e0905acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0ef3161f926bef80f12aa4e0905acd">&#9670;&nbsp;</a></span>AK_delete_extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_delete_extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that deletes an extent between the first and the last block. </p>
<dl class="section author"><dt>Author</dt><dd>Dejan Sambolić </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>address of extent's first block </td></tr>
    <tr><td class="paramname">end</td><td>address of extent's last block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if extent has been successfully deleted, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="a0a6e9ee9800548168a235c26fcceba71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6e9ee9800548168a235c26fcceba71">&#9670;&nbsp;</a></span>AK_delete_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_delete_segment </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Mislav Èakariæ, fixed by Josip Susnjara </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the segment </td></tr>
    <tr><td class="paramname">type</td><td>type of the segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if extent has been successfully deleted, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="a05e85dd0d7290cf56aa9ef24070cea0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e85dd0d7290cf56aa9ef24070cea0a">&#9670;&nbsp;</a></span>AK_get_allocation_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_get_allocation_set </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>allocationSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromWhere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gaplength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRequestedBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function prepare demanded sets from allocation table. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocationSet</td><td>Pointer to array which will be filled and represent the allocation set </td></tr>
    <tr><td class="paramname">fromWhere</td><td>Has meaning only if mode is SEQUENCE. It describes from which address searching starts. </td></tr>
    <tr><td class="paramname">gaplength</td><td>Tells how many used blocks can be tolerated in allocation set </td></tr>
    <tr><td class="paramname">numRequestedBlocks</td><td>Tells how many AK_free blocks have been requested </td></tr>
    <tr><td class="paramname">mode</td><td>Defines how to obtain set of indexes to AK_free addresses </td></tr>
    <tr><td class="paramname">target</td><td>Has meaning just if mode is AROUND: set will be as close as possible to the requested target address from both sides </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first element of the allocation set </dd></dl>

</div>
</div>
<a id="a9525b11c47b5825abb4956add526623c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9525b11c47b5825abb4956add526623c">&#9670;&nbsp;</a></span>AK_get_extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* AK_get_extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>desired_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that allocates new extent of blocks. Number of blocks is not ordered as well as a way of search for them. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_address</td><td>address (block number) to start searching for sufficient space </td></tr>
    <tr><td class="paramname">desired_size</td><td>number of desired blocks </td></tr>
    <tr><td class="paramname">AK_allocation_set_mode</td><td>a way of trying to fing AK_free space. Can be one of: allocationSEQUENCE, allocationUPPER, allocationLOWER, allocationAROUND </td></tr>
    <tr><td class="paramname">border</td><td>number of allocated blocks gap </td></tr>
    <tr><td class="paramname">target</td><td>block address around which other blocks have to be searched </td></tr>
    <tr><td class="paramname">header</td><td>pointer to header that should be written to the new extent (all blocks) </td></tr>
    <tr><td class="paramname">int</td><td>gl gap size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to set of alocated block addresses </dd></dl>
<p>vars for loop [for]</p>
<p>if some blocks are not succesfully allocated, which means that the extend allocation has FAILED</p>

</div>
</div>
<a id="a9411aae916046fdd8e53ed1760a58b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9411aae916046fdd8e53ed1760a58b6d">&#9670;&nbsp;</a></span>AK_increase_extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* AK_increase_extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>add_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dbman_8h.html#af6d80074e26af6570de6d650c1d90851">AK_allocation_set_mode</a> *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that allocates a new blocks for increasing extent size. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_address</td><td>first address of extent that is subject of increasing </td></tr>
    <tr><td class="paramname">add_size</td><td>number how many new blocks is to be added to existing extent </td></tr>
    <tr><td class="paramname">AK_allocation_set_mode</td><td>a way of trying to fing AK_free space. Can be one of: allocationSEQUENCE, allocationUPPER, allocationLOWER, allocationAROUND </td></tr>
    <tr><td class="paramname">border</td><td>number of allocated blocks gap </td></tr>
    <tr><td class="paramname">target</td><td>block address around which other blocks have to be searched </td></tr>
    <tr><td class="paramname">header</td><td>pointer to header that should be written to the new extent (all blocks) </td></tr>
    <tr><td class="paramname">int</td><td>gl gap size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to set of alocated block addresses </dd></dl>

</div>
</div>
<a id="aee0b4429858370953a410c6fb5b9ec92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0b4429858370953a410c6fb5b9ec92">&#9670;&nbsp;</a></span>AK_init_allocation_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_allocation_table </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes the allocation table, writes it to the disk and caches it in memory. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the file has been written to disk, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="a402f984ce7298e193a2a9c5dc5d6b901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402f984ce7298e193a2a9c5dc5d6b901">&#9670;&nbsp;</a></span>AK_init_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAK__block.html">AK_block</a>* AK_init_block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes new block. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten , rearranged by dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to block allocated in memory </dd></dl>

</div>
</div>
<a id="a7cacca7e9aebff2aee36f85632e5c35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cacca7e9aebff2aee36f85632e5c35e">&#9670;&nbsp;</a></span>AK_init_db_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_db_file </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes a new database file named DB_FILE. It opens database file. New block is allocated. In this block type of header is set to FREE_INT, attribute names are set to FREE_CHAR, integrities are set to FREE_INT, constraint names are set to FREE_CHAR, constraint names and codes are set to FREE_CHAR. Type, address and size of tuples are set to FREE_INT. Data in block is set to FREE_CHAR. Type of block is BLOCK_TYPE_FREE, it is not chained and id of last tuple is 0. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of new file in in blocks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the file has been written to disk, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="a7e7d6a4c56ce0c15b59217a3607db06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7d6a4c56ce0c15b59217a3607db06e">&#9670;&nbsp;</a></span>AK_init_disk_manager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_disk_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section author"><dt>Author</dt><dd>Markus Schatten </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Function that calls functions <a class="el" href="dbman_8c.html#a7cacca7e9aebff2aee36f85632e5c35e" title="Function that initializes a new database file named DB_FILE. It opens database file....">AK_init_db_file()</a> and <a class="el" href="dbman_8c.html#af99cdc5c8456ad5ff87fb542d030c4d6" title="Function that initializes the system catalog. Headers for system tables are defined....">AK_init_system_catalog()</a> to initialize disk manager. It also calls AK_allocate_array_currently_accessed_blocks() to allocate memory needed for thread-safe reading and writing to disk. </dd></dl>

</div>
</div>
<a id="af99cdc5c8456ad5ff87fb542d030c4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af99cdc5c8456ad5ff87fb542d030c4d6">&#9670;&nbsp;</a></span>AK_init_system_catalog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_system_catalog </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initializes the system catalog. Headers for system tables are defined. Segments for those system tables are allocated. Above function <a class="el" href="dbman_8c.html#af4c050534ddf6dcf1cba09987424ff76" title="Function that registers system tables. Block at the given address is read. Various data from function...">AK_register_system_tables()</a> to register system tables. </p>
<dl class="section author"><dt>Author</dt><dd>Miroslav Policki </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if the system catalog has been successfully initialized, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="ac48430852cddc2cc7b79dd2775212b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48430852cddc2cc7b79dd2775212b10">&#9670;&nbsp;</a></span>AK_init_system_tables_catalog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_init_system_tables_catalog </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>function_arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trigger_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>db_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintNull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintUnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that initialises the sytem table catalog and writes the result in first (0) block in db_file. Catalog block, catalog header name, catalog header address are allocated. Address, type, chained_with and AK_free_space attributes are initialized. Names of various database elements are written in block. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>address of system table of relation in db_file </td></tr>
    <tr><td class="paramname">attribute</td><td>address of system table of attribute in db_file </td></tr>
    <tr><td class="paramname">index</td><td>address of system table of index in db_file </td></tr>
    <tr><td class="paramname">view</td><td>address of system table of view in db_file </td></tr>
    <tr><td class="paramname">sequence</td><td>address of system table of sequence in db_file </td></tr>
    <tr><td class="paramname">function</td><td>address of system table of function in db_file </td></tr>
    <tr><td class="paramname">function_arguments</td><td>address of system table of function_arguments in db_file </td></tr>
    <tr><td class="paramname">trigger</td><td>address of system table of trigger in db_file </td></tr>
    <tr><td class="paramname">trigger_conditions</td><td>address of system table of trigger_conditions in db_file </td></tr>
    <tr><td class="paramname">db</td><td>address of system table of db in db_file </td></tr>
    <tr><td class="paramname">db_obj</td><td>address of system table of db_obj in db_file </td></tr>
    <tr><td class="paramname">user</td><td>address of system table of user in db_file </td></tr>
    <tr><td class="paramname">group</td><td>address of system table of group in db_file </td></tr>
    <tr><td class="paramname">user_group</td><td>address of system table of users associated with groups in db_file </td></tr>
    <tr><td class="paramname">user_right</td><td>address of system table of user right in db_file </td></tr>
    <tr><td class="paramname">group_right</td><td>address of system table of group right in db_file </td></tr>
    <tr><td class="paramname">constraint</td><td>address of system table of constraint in db_file </td></tr>
    <tr><td class="paramname">constraintNull</td><td>address of system table of constraintNull in db_file </td></tr>
    <tr><td class="paramname">constraintCheck</td><td>system table address for check constraint </td></tr>
    <tr><td class="paramname">reference</td><td>address of system table of reference in db_file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if initialization was succesful if not returns EXIT_ERROR </dd></dl>
<p>first header attribute of catalog_block</p>
<p>second attribute of catalog_block</p>
<p>initialize other elements of block (adress, type, chained_with, AK_free_space)</p>
<p>using as an address for the first AK_free space in block-&gt;data</p>
<p>merge catalog_heder with heders created before</p>

</div>
</div>
<a id="a0f011234546a9f1cc751a0d08036b131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f011234546a9f1cc751a0d08036b131">&#9670;&nbsp;</a></span>AK_insert_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_insert_entry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>block_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>entry_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that inserts an entry in tuple_dict and data of a block. Address, type and size of catalog_tuple_dict are set. Free space of block is also set. </p>
<dl class="section author"><dt>Author</dt><dd>Matija Novak </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_adress</td><td>adress of a block in which we want insert data </td></tr>
    <tr><td class="paramname">type</td><td>type of entry_data </td></tr>
    <tr><td class="paramname">entry_data</td><td>(char) data which is inserted, can be int but must first be converted to char </td></tr>
    <tr><td class="paramname">i</td><td>(int) adress in tuple_dict array (example block_address-&gt;tuple_dict[i]) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value because it gets the address of an block like a function parameter and works directly with the orginal block </dd></dl>
<p>copy data into bloc-&gt;data on start position bloc-&gt;AK_free_space</p>
<p>address of entry data in block-&gt;data</p>
<p>calculate next AK_free space for the next entry data</p>
<p>sizeof(entry_data)+1);///(sizeof(int)); no need for "+strlen(entry_data)" while "+1" is like "new line"</p>
<p>type of entry data</p>
<p>size of entry data</p>
<p>copy tuple_dict to block-&gt;tuple_dict[i] must use &amp; becouse tuple_dict[i] is value and catalog_tuple_dict adress</p>

</div>
</div>
<a id="a3157bc3da79c19192a915acc1235bad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3157bc3da79c19192a915acc1235bad0">&#9670;&nbsp;</a></span>AK_memset_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AK_memset_int </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that sets the first num ints of a block of memory to the specified value. </p>
<dl class="section author"><dt>Author</dt><dd>Miroslav Policki </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>pointer to the block of memory to fill </td></tr>
    <tr><td class="paramname">value</td><td>int value to be set </td></tr>
    <tr><td class="paramname">num</td><td>number of ints in the block of memory to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>No return value </dd></dl>

</div>
</div>
<a id="a1ff7d6ea92a45cda91ff2063043900a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff7d6ea92a45cda91ff2063043900a1">&#9670;&nbsp;</a></span>AK_new_extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_new_extent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>old_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extent_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that allocates new extent of blocks. If argument "old_size" is 0 than size of extent is INITIAL_EXTENT_SIZE. Otherwise, resize factor is set according to type of extent. If writing of block is successful, number of blocks is incremented. </p>
<dl class="section author"><dt>Author</dt><dd>Nikola Bakoš, updated by Dino Laktašiæ (fixed header BUG), refurbished by dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_address</td><td>address (block number) to start searching for sufficient space </td></tr>
    <tr><td class="paramname">old_size</td><td>size of previous extent in same segment (in blocks) </td></tr>
    <tr><td class="paramname">extent_type</td><td>type of extent (can be one of: SEGMENT_TYPE_SYSTEM_TABLE, SEGMENT_TYPE_TABLE, SEGMENT_TYPE_INDEX, SEGMENT_TYPE_TRANSACTION, SEGMENT_TYPE_TEMP </td></tr>
    <tr><td class="paramname">header</td><td>pointer to header that should be written to the new extent (all blocks) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address (block number) of new extent if successful, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="a79e7998e69e2910528f7ef258469b2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e7998e69e2910528f7ef258469b2be">&#9670;&nbsp;</a></span>AK_new_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_new_segment </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAK__header.html">AK_header</a> *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that allocates new segment of extents. In this phase of implementation, only extents containing INITIAL_EXTENT_SIZE blocks can be allocated. If extent is successfully allocated, number of allocated extents is incremented and function goes to next block after allocated extent. Otherwise, function moves to INITIAL_EXTENT_SIZE blocks. In that way function gets either first block of new extent or some block in that extent which will not be AK_free. </p>
<dl class="section author"><dt>Author</dt><dd>Tomislav Fotak, refurbished by dv </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>(character pointer) name of segment </td></tr>
    <tr><td class="paramname">type</td><td>segment type (possible values: SEGMENT_TYPE_SYSTEM_TABLE, SEGMENT_TYPE_TABLE, SEGMENT_TYPE_INDEX, SEGMENT_TYPE_TRANSACTION, SEGMENT_TYPE_TEMP) </td></tr>
    <tr><td class="paramname">header</td><td>(header pointer) pointer to header that should be written to the new extent (all blocks) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS for success or EXIT_ERROR if some error occurs </dd></dl>
<p>start address for segment because we can not allocate segment in block 0</p>

</div>
</div>
<a id="a3fcca519b1dbe309c683d64b0e955dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcca519b1dbe309c683d64b0e955dca">&#9670;&nbsp;</a></span>AK_print_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_print_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>gg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fpp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that dumps a block. </p>
<dl class="section author"><dt>Author</dt><dd>dv </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>nothing </dd></dl>

</div>
</div>
<a id="a2c880db7cf4f8332ae7e93c6b71cc911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c880db7cf4f8332ae7e93c6b71cc911">&#9670;&nbsp;</a></span>AK_read_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAK__block.html">AK_block</a>* AK_read_block </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that reads a block at a given address (block number less than db_file_size). New block is allocated. Database file is opened. Position is set to provided address block. At the end function reads file from that position. Completely thread-safe. </p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten, updated by dv and Domagoj Šitum (thread-safe enabled) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>block number (address) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to block allocated in memory </dd></dl>

</div>
</div>
<a id="a5499694bd97b104560d14ef70abe2c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5499694bd97b104560d14ef70abe2c73">&#9670;&nbsp;</a></span>AK_read_block_for_testing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AK_read_block_for_testing </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is only for testing. It has to be there, because pthread_create only accepts void* function_name (void *) function format. So AK_read_block is no-go for pthread_create. </p>
<dl class="section author"><dt>Author</dt><dd>Domagoj Šitum </dd></dl>

</div>
</div>
<a id="af4c050534ddf6dcf1cba09987424ff76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c050534ddf6dcf1cba09987424ff76">&#9670;&nbsp;</a></span>AK_register_system_tables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_register_system_tables </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>relation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>function_arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trigger_conditions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>db_obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>user_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintNull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>constraintUnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that registers system tables. Block at the given address is read. Various data from function arguments are written in block about different database elements. </p>
<dl class="section author"><dt>Author</dt><dd>Unknown </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relation</td><td>relation in database </td></tr>
    <tr><td class="paramname">attribute</td><td>attribute in databse </td></tr>
    <tr><td class="paramname">index</td><td>index in database </td></tr>
    <tr><td class="paramname">view</td><td>view in database </td></tr>
    <tr><td class="paramname">sequence</td><td>sequence in database </td></tr>
    <tr><td class="paramname">function</td><td>function in database </td></tr>
    <tr><td class="paramname">function_arguments</td><td>functional_arguments in databse </td></tr>
    <tr><td class="paramname">trigger</td><td>trigger in database </td></tr>
    <tr><td class="paramname">trigger_conditions</td><td>trigger conditions in databse </td></tr>
    <tr><td class="paramname">db</td><td>database </td></tr>
    <tr><td class="paramname">db_obj</td><td>database object </td></tr>
    <tr><td class="paramname">user</td><td>user in database </td></tr>
    <tr><td class="paramname">group</td><td>group in database </td></tr>
    <tr><td class="paramname">user_group</td><td>user associated with group in database </td></tr>
    <tr><td class="paramname">user_right</td><td>user right in database </td></tr>
    <tr><td class="paramname">group_right</td><td>group right in database </td></tr>
    <tr><td class="paramname">constraint</td><td>constraint in database </td></tr>
    <tr><td class="paramname">constraintNull</td><td>Null constraint in database </td></tr>
    <tr><td class="paramname">constraintCheck</td><td>Check constraint in database </td></tr>
    <tr><td class="paramname">reference</td><td>reference database </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS </dd></dl>

</div>
</div>
<a id="a9e8396012164fedd2cfae7bf6f6ae0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8396012164fedd2cfae7bf6f6ae0cc">&#9670;&nbsp;</a></span>AK_thread_safe_block_access_test()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTestResult.html">TestResult</a> AK_thread_safe_block_access_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function tests thread safe reading and writing to blocks. There is N writing and N reading threads, which are going through iterations. Each reading thread should read the data (character) that was set by last writing thread. </p>
<dl class="section author"><dt>Author</dt><dd>Domagoj Šitum </dd></dl>

</div>
</div>
<a id="a222ea31aa276d52e464137a3b144f78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222ea31aa276d52e464137a3b144f78a">&#9670;&nbsp;</a></span>AK_write_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AK_write_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAK__block.html">AK_block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that writes a block to the DB file. Database file is opened. Position is set to provided address block. Block is written to provided address. Completely thread-safe. </p>
<p>Function that writes the new value in block when index is updated.</p>
<dl class="section author"><dt>Author</dt><dd>Markus Schatten, updated by Domagoj Šitum (thread-safe enabled) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>poiner to block allocated in memory to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EXIT_SUCCESS if successful, EXIT_ERROR otherwise </dd></dl>

</div>
</div>
<a id="a0558e034eeed865a1c855de5cfad20ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0558e034eeed865a1c855de5cfad20ef">&#9670;&nbsp;</a></span>AK_write_block_for_testing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* AK_write_block_for_testing </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is only for testing. It has to be there, because pthread_create only accepts void* function_name (void *) function format. So AK_write_block is no-go for pthread_create. </p>
<dl class="section author"><dt>Author</dt><dd>Domagoj Šitum </dd></dl>

</div>
</div>
<a id="adbc6978517271fbd48a004cb039ac6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc6978517271fbd48a004cb039ac6c1">&#9670;&nbsp;</a></span>fsize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fsize </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to determine file size. </p>
<dl class="section return"><dt>Returns</dt><dd>file size </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa74b62e850a091e2305da8dc8ab1e1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74b62e850a091e2305da8dc8ab1e1de">&#9670;&nbsp;</a></span>fileLockMutex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t fileLockMutex = PTHREAD_MUTEX_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a75d8194a70159d3603f73699e7f1ed6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d8194a70159d3603f73699e7f1ed6f">&#9670;&nbsp;</a></span>test_lastCharacterWritten</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">test_lastCharacterWritten = '\0'</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable is used only when TEST_MODE is ON! It is used only for testing functionality of <a class="el" href="dbman_8c.html#a9e8396012164fedd2cfae7bf6f6ae0cc" title="This function tests thread safe reading and writing to blocks. There is N writing and N reading threa...">AK_thread_safe_block_access_test()</a> function. It will contain first character of last written block. When reading thread reads the block (written by some other thread), it will compare the first character from this block to character containted in this wariables. If they don't match, then the error occured! It is assumed that the same block is being written to and read from (just like AK_thread_safe_block_access_test function works!) </p>

</div>
</div>
<a id="aef8ef161a5a8600479cc77f15d7b859e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8ef161a5a8600479cc77f15d7b859e">&#9670;&nbsp;</a></span>test_threadSafeBlockAccessSucceeded</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">test_threadSafeBlockAccessSucceeded = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used in combination with test_lastCharacterWritten. Will give the answer to question: "Has AK_thread_safe_block_access_test suceeded?" 0 means NO, 1 means YES. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_fceb8c84259f2f7a80548922c61f7c5a.html">dm</a></li><li class="navelem"><a class="el" href="dbman_8c.html">dbman.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
